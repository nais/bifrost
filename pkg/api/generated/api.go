// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for UnleashConfigRequestLogLevel.
const (
	Debug UnleashConfigRequestLogLevel = "debug"
	Error UnleashConfigRequestLogLevel = "error"
	Fatal UnleashConfigRequestLogLevel = "fatal"
	Info  UnleashConfigRequestLogLevel = "info"
	Warn  UnleashConfigRequestLogLevel = "warn"
)

// ErrorResponse Standard error response structure
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]string `json:"details,omitempty"`

	// Error Error code/identifier
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`

	// StatusCode HTTP status code
	StatusCode int `json:"status_code"`
}

// ReleaseChannelResponse Release channel information for Unleash version management
type ReleaseChannelResponse struct {
	// CreatedAt Timestamp when the release channel was created (RFC3339 format)
	CreatedAt time.Time `json:"created_at"`

	// CurrentVersion Current version tracked by the release channel status
	CurrentVersion string `json:"current_version"`

	// Description **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Description *string `json:"description,omitempty"`

	// Image Full container image reference including tag
	Image string `json:"image"`

	// LastUpdated Timestamp when the release channel image was last changed (RFC3339 format)
	LastUpdated *time.Time `json:"last_updated,omitempty"`

	// Name Unique identifier of the release channel (e.g., "stable", "rapid")
	Name string `json:"name"`

	// Schedule **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Schedule *string `json:"schedule,omitempty"`

	// Type **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Type *string `json:"type,omitempty"`

	// Version **Deprecated:** Use 'image' instead. This field returns the same value as 'image'.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Version *string `json:"version,omitempty"`
}

// Unleash Unleash CRD (Custom Resource Definition) representing an Unleash feature flag server instance.
// This is a Kubernetes resource managed by the unleasherator operator.
type Unleash struct {
	ApiVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Metadata   *struct {
		CreationTimestamp *time.Time `json:"creationTimestamp,omitempty"`
		Name              *string    `json:"name,omitempty"`
		Namespace         *string    `json:"namespace,omitempty"`
	} `json:"metadata,omitempty"`

	// Spec Desired state of the Unleash instance
	Spec *struct {
		// CustomImage Custom container image override
		CustomImage *string `json:"customImage,omitempty"`

		// Federation Federation configuration
		Federation *struct {
			AllowedClusters *[]string `json:"allowedClusters,omitempty"`
			AllowedTeams    *[]string `json:"allowedTeams,omitempty"`
			Enabled         *bool     `json:"enabled,omitempty"`
		} `json:"federation,omitempty"`

		// ReleaseChannel Name of the release channel for automatic version updates
		ReleaseChannel *string `json:"releaseChannel,omitempty"`
	} `json:"spec,omitempty"`

	// Status Observed state of the Unleash instance
	Status *struct {
		// Connected Connection status to database
		Connected *bool `json:"connected,omitempty"`

		// Version Current running version
		Version *string `json:"version,omitempty"`
	} `json:"status,omitempty"`
}

// UnleashConfigRequest Request body for creating or updating an Unleash instance
type UnleashConfigRequest struct {
	// AllowedClusters Comma-separated list of allowed clusters for federation
	AllowedClusters *string `json:"allowed_clusters,omitempty"`

	// AllowedTeams Comma-separated list of allowed teams for federation
	AllowedTeams *string `json:"allowed_teams,omitempty"`

	// DatabasePoolIdleTimeoutMs Database connection idle timeout in milliseconds
	DatabasePoolIdleTimeoutMs *int `json:"database_pool_idle_timeout_ms,omitempty"`

	// DatabasePoolMax Maximum number of database connections
	DatabasePoolMax *int `json:"database_pool_max,omitempty"`

	// EnableFederation Enable federation support (always enabled for managed instances)
	EnableFederation *bool `json:"enable_federation,omitempty"`

	// LogLevel Log level for the Unleash instance
	LogLevel *UnleashConfigRequestLogLevel `json:"log_level,omitempty"`

	// Name Name of the Unleash instance
	Name *string `json:"name,omitempty"`

	// ReleaseChannelName Name of the release channel to use for automatic version updates
	ReleaseChannelName *string `json:"release_channel_name,omitempty"`
}

// UnleashConfigRequestLogLevel Log level for the Unleash instance
type UnleashConfigRequestLogLevel string

// CreateInstanceJSONRequestBody defines body for CreateInstance for application/json ContentType.
type CreateInstanceJSONRequestBody = UnleashConfigRequest

// UpdateInstanceJSONRequestBody defines body for UpdateInstance for application/json ContentType.
type UpdateInstanceJSONRequestBody = UnleashConfigRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all release channels
	// (GET /releasechannels)
	ListChannels(c *gin.Context)
	// Get a release channel by name
	// (GET /releasechannels/{name})
	GetChannel(c *gin.Context, name string)
	// List all Unleash instances
	// (GET /unleash)
	ListInstances(c *gin.Context)
	// Create a new Unleash instance
	// (POST /unleash)
	CreateInstance(c *gin.Context)
	// Delete an Unleash instance
	// (DELETE /unleash/{name})
	DeleteInstance(c *gin.Context, name string)
	// Get Unleash instance by name
	// (GET /unleash/{name})
	GetInstance(c *gin.Context, name string)
	// Update an existing Unleash instance
	// (PUT /unleash/{name})
	UpdateInstance(c *gin.Context, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListChannels operation middleware
func (siw *ServerInterfaceWrapper) ListChannels(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListChannels(c)
}

// GetChannel operation middleware
func (siw *ServerInterfaceWrapper) GetChannel(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetChannel(c, name)
}

// ListInstances operation middleware
func (siw *ServerInterfaceWrapper) ListInstances(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListInstances(c)
}

// CreateInstance operation middleware
func (siw *ServerInterfaceWrapper) CreateInstance(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateInstance(c)
}

// DeleteInstance operation middleware
func (siw *ServerInterfaceWrapper) DeleteInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteInstance(c, name)
}

// GetInstance operation middleware
func (siw *ServerInterfaceWrapper) GetInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetInstance(c, name)
}

// UpdateInstance operation middleware
func (siw *ServerInterfaceWrapper) UpdateInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateInstance(c, name)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/releasechannels", wrapper.ListChannels)
	router.GET(options.BaseURL+"/releasechannels/:name", wrapper.GetChannel)
	router.GET(options.BaseURL+"/unleash", wrapper.ListInstances)
	router.POST(options.BaseURL+"/unleash", wrapper.CreateInstance)
	router.DELETE(options.BaseURL+"/unleash/:name", wrapper.DeleteInstance)
	router.GET(options.BaseURL+"/unleash/:name", wrapper.GetInstance)
	router.PUT(options.BaseURL+"/unleash/:name", wrapper.UpdateInstance)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xabW8buRH+KwRb4HKB3hz7ClTfcnJyFXqXBo7TD40NgdodybxwyQ1f5AiB/nsxJFf7",
	"Rtmyc/X5Q4EAUXb5Mhw+88wzs/lGM1WUSoK0hk6/UZPdQMH8zzdaK30BplTSAD7IwWSal5YrSaf0g2Uy",
	"ZzongOOIjgOJsdpl1mmgA1pqVYK2HEyYbxkX/ifLc47rMPG+NcRuS6BTaqzmck13g86er/fT4q7VkgMK",
	"X1lRCm8nl8YymeFCxXbopABmbnCxuLpa/g6ZxQd+kf7R/MlJpnIY8xyk5SsOurkHlcouVsrJnA76Nhdg",
	"DFsnXPYPVzA51MBythQQj1CNbi7/MdhMqpMQqSw5uJ+xzDqzQHsTe15evidhhD9Rc5+zydl+OS4trEHT",
	"3W5ANXxxXENOp5+ii+pDtbe7Tjj1AtB4mN0wKUEcBlAcR7IwkHC5Urpg+JaslCaVEzagDT4rmGRrKEDa",
	"HrIyDcxCvmC2v80lL8BYVpTk9gYksTdAdGfnW2ZIXIK8uHg7Oz09/TsJxvzYupdXk1dnw8nJcHJyOZlM",
	"/Z//0AENQ+mU5szC0PICUteUOa1B2kU8T9/SWRiwP7DVLPsMOVluk1aHe2jZ97fR6WiS2ru1Ee5basjw",
	"vHRqtYNunL18eb4fMX35klzecENWHEROuMFQB72B3N/SymGsE2eAMJkTJm7ZFodYp6UhTBIoSrslwZTR",
	"lUxZx4tkuLx1QpBMScu4BE38KKJhBRowJrjMhMu5XBPL1i03fHFsO+JqHEO/+nvozdbTg14SzNiFK/Pg",
	"mEcAKZiIcMKl/OP1cZg6HZ78dHkymZ4+DFOSFQnHfZT8iwNScxdRq6S9L2C0Hg3IFcb0UsAVxd+alTy/",
	"om0rw4Ak+2Q3kDsBzxBX4cGzM6tFAA+z7KMB8oNH2Q8+OQDLR01zK0Pwsg0rgGyYcECYqWYFk743VDo5",
	"wqOwCuNBk437rJfKGJHpU0AOKWB2cU5ezJyxqiAXYJTTGZBzWHHp5cCPRKOXDMJdrvEWqokrYP6+VoKt",
	"STjTPqmOrqT3HDeEkX+6JWgJFvx9hw1Cwtnzb3QNaGaVJph+8EdwaDsdsZL/u77j2tlxhZFk3KDTNycp",
	"eHzmMm/Pq/yT1BqW5cwynJDIiVzJPW211/yuVFbRTr1cQ2gdGG9KlvUnWWBFEl89kJgSsj5CzsEgCn0y",
	"hIrmuvKprxc8lObptBNx1k08agNa87aAenSmWUGO8EnKgLf7d2jDiq9dHNmDmRDqFvKZcMaCNi3ffqI5",
	"bIbrrAyzcv/zekC5hSKttOMDpjXb4r/j6pfAiu7SeGlDhufCH8uHrQsSM0kb4YH64silUgKYTKNAt8Rl",
	"33nvkPQOZDvkb+asQo2Z7VVWyPfmqGyXxGWQYT1L/rWMaeOB0FRSQpYUILPwCo2Ogt4qgsG/ZKYFy7Q7",
	"O4knpTy1kxIZtBp4hLbsu6T3ZEC/Dj/v+XVY8Wuws6b/mQf7BXxxYGyqXPAvyFLlW3+VgeDkmigdLrHD",
	"/QddHJG9yBqB0/V0UbChgZJpXxQIbizeYJxJqplBEtSx3PRXjL/BPvoSNFBZYqsge5gZftpdNoRAHcQw",
	"TdUFET2LUimx4LmABXK+cnaRMug8DidZDUWcROIkwiUpuBDcQKZk3gqq08lkMumXm10bCva1v+9v7Csv",
	"XEGkK5ZBzeZ9S1q7nSS3CtyzuIt93/ghDYcS48pSaUteRLEXCcz7vZIIFdbMj8fEoVDrhYBNir9+VWvi",
	"X/nlDzAGSFcEil86rHywcqYDesu0v/5Ysa+YZQK5ucZDHHhkGdHk0pQVRyb/SMOLSMOL+zfrErdVXnD/",
	"L/gbH3mvBOq1LPPUE2yk717PP5DLIFGcFnRKb6wtzXQ8XnN745ajTBVjVHPjJV9pZWy/ZfVzeEFev5/X",
	"iEGmOkaiGl9kdNxhMMpqvTq6klHI4halVhueA6I0LxWX1rS4ckA0sNz/qChz4PfIQYBtmrU3YXAlmSG3",
	"IASWEV8c6K0n2g3jwodKzzzcsN+0CUJZ8AxiNyj6+Lf55bHeHS+FWo4LxuX41/nszbsPb7zA4NZfesPT",
	"tJHr6MlogsNUCZKVnE7p6WgyOsWswOyNJ7lxPEJ1Any2hmQOinVek4rvc8WdfaxQRnAl5zlGPzd2VhmB",
	"kRN6Z96gV5NJBVKc6suMUvDMzx7/bgKZhf6t74JWiuyvGlZ0Sv8yrju949jmHR/o1fVk266H6w8uy8CY",
	"lRNii2Wn5rBppKiuJ3DJnx54grsMbzenE/bNpQUtmahCKrAijjOuKJjeRnf7G+xZO6CWrQ1ybHw13L+6",
	"xjW6iBl/QzTv7gVO7Fd75BCsaPiKZ93te7D4BSpUeNRqVkDQLZ/u66lWlTm+Q7jTiuurmr0u40Oyqr1/",
	"BJtefydEH4PMo5HYdepuQM8mZ08HwN5V7Fv4bRD+ApawXspbbqu7uweIru6dPICyjkw+ptkXmV2cmyRj",
	"zasJT0JZH3vfcx7LUfuDPm9y6mXkBiiqfsPmhF7vBrRUqcpp5vtxCAEJt0ddPbnl9qbW2CgQMg2+ncwE",
	"Ko6LRp+xDZGQ5tsgCQbMa+moQy33s8q3f5jTk1Xkrt2qjAVnB6Qnf7QN92Kx+ti0V9OenJ4UgBsmOJJk",
	"KKpRseGDUPFEOD7DoAhI6iC5UZMk46JBk4087RUvpDqKwmOZSQJfuUmKYh8R3CJDGpVxf5eHoqUXDWGD",
	"RjTcmdHn+0/Aj0/l9+fts8T3/SZgg7PyJ0+i8/4H8OcIy3ClB5pPB7j6ETqxD8Nugk5Jx+eFtMmTk22d",
	"+Nt0+yfDuCcCe7fb14DddO8SEPoY+iHtbwceSHcQ2uhKvo/fOU2r9wUWxxvCV972CEXIR+RhEiBY9adD",
	"8TnJjqePhPhfG5697Ph/iumnmBBAdwbxQf2DC/mVU7H2+v2c+A/RoQU33pxQjJW40qEv8nuSqrtZZB/x",
	"pg7ThiG7wX3dinqBAz3Eet1eNby73v03AAD//+Ww09HMKAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
