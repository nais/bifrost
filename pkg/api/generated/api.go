// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for UnleashConfigRequestLogLevel.
const (
	Debug UnleashConfigRequestLogLevel = "debug"
	Error UnleashConfigRequestLogLevel = "error"
	Fatal UnleashConfigRequestLogLevel = "fatal"
	Info  UnleashConfigRequestLogLevel = "info"
	Warn  UnleashConfigRequestLogLevel = "warn"
)

// ErrorResponse Standard error response structure
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]string `json:"details,omitempty"`

	// Error Error code/identifier
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`

	// StatusCode HTTP status code
	StatusCode int `json:"status_code"`
}

// ReleaseChannelResponse Release channel information for Unleash version management
type ReleaseChannelResponse struct {
	// CreatedAt Timestamp when the release channel was created (RFC3339 format)
	CreatedAt time.Time `json:"created_at"`

	// CurrentVersion Current version tracked by the release channel status
	CurrentVersion string `json:"current_version"`

	// Description **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Description *string `json:"description,omitempty"`

	// Image Full container image reference including tag
	Image string `json:"image"`

	// LastUpdated Timestamp when the release channel image was last changed (RFC3339 format)
	LastUpdated *time.Time `json:"last_updated,omitempty"`

	// Name Unique identifier of the release channel (e.g., "stable", "rapid")
	Name string `json:"name"`

	// Schedule **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Schedule *string `json:"schedule,omitempty"`

	// Type **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Type *string `json:"type,omitempty"`

	// Version **Deprecated:** Use 'image' instead. This field returns the same value as 'image'.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Version *string `json:"version,omitempty"`
}

// Unleash Unleash CRD (Custom Resource Definition) representing an Unleash feature flag server instance.
// This is a Kubernetes resource managed by the unleasherator operator.
type Unleash struct {
	ApiVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Metadata   *struct {
		CreationTimestamp *time.Time `json:"creationTimestamp,omitempty"`
		Name              *string    `json:"name,omitempty"`
		Namespace         *string    `json:"namespace,omitempty"`
	} `json:"metadata,omitempty"`

	// Spec Desired state of the Unleash instance
	Spec *struct {
		// CustomImage Custom container image override
		CustomImage *string `json:"customImage,omitempty"`

		// Federation Federation configuration
		Federation *struct {
			AllowedClusters *[]string `json:"allowedClusters,omitempty"`
			AllowedTeams    *[]string `json:"allowedTeams,omitempty"`
			Enabled         *bool     `json:"enabled,omitempty"`
		} `json:"federation,omitempty"`

		// ReleaseChannel Release channel configuration for automatic version updates
		ReleaseChannel *struct {
			// Name Name of the release channel
			Name *string `json:"name,omitempty"`
		} `json:"releaseChannel,omitempty"`
	} `json:"spec,omitempty"`

	// Status Observed state of the Unleash instance
	Status *struct {
		// Connected Connection status to database
		Connected *bool `json:"connected,omitempty"`

		// Version Current running version
		Version *string `json:"version,omitempty"`
	} `json:"status,omitempty"`
}

// UnleashConfigRequest Request body for creating or updating an Unleash instance
type UnleashConfigRequest struct {
	// AllowedClusters Comma-separated list of allowed clusters for federation
	AllowedClusters *string `json:"allowed_clusters,omitempty"`

	// AllowedTeams Comma-separated list of allowed teams for federation
	AllowedTeams *string `json:"allowed_teams,omitempty"`

	// DatabasePoolIdleTimeoutMs Database connection idle timeout in milliseconds
	DatabasePoolIdleTimeoutMs *int `json:"database_pool_idle_timeout_ms,omitempty"`

	// DatabasePoolMax Maximum number of database connections
	DatabasePoolMax *int `json:"database_pool_max,omitempty"`

	// EnableFederation Enable federation support (always enabled for managed instances)
	EnableFederation *bool `json:"enable_federation,omitempty"`

	// LogLevel Log level for the Unleash instance
	LogLevel *UnleashConfigRequestLogLevel `json:"log_level,omitempty"`

	// Name Name of the Unleash instance
	Name *string `json:"name,omitempty"`

	// ReleaseChannelName Name of the release channel to use for automatic version updates
	ReleaseChannelName *string `json:"release_channel_name,omitempty"`
}

// UnleashConfigRequestLogLevel Log level for the Unleash instance
type UnleashConfigRequestLogLevel string

// CreateInstanceJSONRequestBody defines body for CreateInstance for application/json ContentType.
type CreateInstanceJSONRequestBody = UnleashConfigRequest

// UpdateInstanceJSONRequestBody defines body for UpdateInstance for application/json ContentType.
type UpdateInstanceJSONRequestBody = UnleashConfigRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all release channels
	// (GET /v1/releasechannels)
	ListChannels(c *gin.Context)
	// Get a release channel by name
	// (GET /v1/releasechannels/{name})
	GetChannel(c *gin.Context, name string)
	// List all Unleash instances
	// (GET /v1/unleash)
	ListInstances(c *gin.Context)
	// Create a new Unleash instance
	// (POST /v1/unleash)
	CreateInstance(c *gin.Context)
	// Delete an Unleash instance
	// (DELETE /v1/unleash/{name})
	DeleteInstance(c *gin.Context, name string)
	// Get Unleash instance by name
	// (GET /v1/unleash/{name})
	GetInstance(c *gin.Context, name string)
	// Update an existing Unleash instance
	// (PUT /v1/unleash/{name})
	UpdateInstance(c *gin.Context, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListChannels operation middleware
func (siw *ServerInterfaceWrapper) ListChannels(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListChannels(c)
}

// GetChannel operation middleware
func (siw *ServerInterfaceWrapper) GetChannel(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetChannel(c, name)
}

// ListInstances operation middleware
func (siw *ServerInterfaceWrapper) ListInstances(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListInstances(c)
}

// CreateInstance operation middleware
func (siw *ServerInterfaceWrapper) CreateInstance(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateInstance(c)
}

// DeleteInstance operation middleware
func (siw *ServerInterfaceWrapper) DeleteInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteInstance(c, name)
}

// GetInstance operation middleware
func (siw *ServerInterfaceWrapper) GetInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetInstance(c, name)
}

// UpdateInstance operation middleware
func (siw *ServerInterfaceWrapper) UpdateInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateInstance(c, name)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/v1/releasechannels", wrapper.ListChannels)
	router.GET(options.BaseURL+"/v1/releasechannels/:name", wrapper.GetChannel)
	router.GET(options.BaseURL+"/v1/unleash", wrapper.ListInstances)
	router.POST(options.BaseURL+"/v1/unleash", wrapper.CreateInstance)
	router.DELETE(options.BaseURL+"/v1/unleash/:name", wrapper.DeleteInstance)
	router.GET(options.BaseURL+"/v1/unleash/:name", wrapper.GetInstance)
	router.PUT(options.BaseURL+"/v1/unleash/:name", wrapper.UpdateInstance)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
