// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for UnleashConfigRequestLogLevel.
const (
	Debug UnleashConfigRequestLogLevel = "debug"
	Error UnleashConfigRequestLogLevel = "error"
	Fatal UnleashConfigRequestLogLevel = "fatal"
	Info  UnleashConfigRequestLogLevel = "info"
	Warn  UnleashConfigRequestLogLevel = "warn"
)

// ErrorResponse Standard error response structure
type ErrorResponse struct {
	// Details Additional error details
	Details *map[string]string `json:"details,omitempty"`

	// Error Error code/identifier
	Error string `json:"error"`

	// Message Human-readable error message
	Message string `json:"message"`

	// StatusCode HTTP status code
	StatusCode int `json:"status_code"`
}

// ReleaseChannelResponse Release channel information for Unleash version management
type ReleaseChannelResponse struct {
	// CreatedAt Timestamp when the release channel was created (RFC3339 format)
	CreatedAt time.Time `json:"created_at"`

	// CurrentVersion Current version tracked by the release channel status
	CurrentVersion string `json:"current_version"`

	// Description **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Description *string `json:"description,omitempty"`

	// Image Full container image reference including tag
	Image string `json:"image"`

	// LastUpdated Timestamp when the release channel image was last changed (RFC3339 format)
	LastUpdated *time.Time `json:"last_updated,omitempty"`

	// Name Unique identifier of the release channel (e.g., "stable", "rapid")
	Name string `json:"name"`

	// Schedule **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Schedule *string `json:"schedule,omitempty"`

	// Type **Deprecated:** This field is reserved for future use and always returns an empty string.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Type *string `json:"type,omitempty"`

	// Version **Deprecated:** Use 'image' instead. This field returns the same value as 'image'.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Version *string `json:"version,omitempty"`
}

// Unleash Unleash CRD (Custom Resource Definition) representing an Unleash feature flag server instance.
// This is a Kubernetes resource managed by the unleasherator operator.
type Unleash struct {
	ApiVersion *string `json:"apiVersion,omitempty"`
	Kind       *string `json:"kind,omitempty"`
	Metadata   *struct {
		CreationTimestamp *time.Time `json:"creationTimestamp,omitempty"`
		Name              *string    `json:"name,omitempty"`
		Namespace         *string    `json:"namespace,omitempty"`
	} `json:"metadata,omitempty"`

	// Spec Desired state of the Unleash instance
	Spec *struct {
		// CustomImage Custom container image override
		CustomImage *string `json:"customImage,omitempty"`

		// Federation Federation configuration
		Federation *struct {
			AllowedClusters *[]string `json:"allowedClusters,omitempty"`
			AllowedTeams    *[]string `json:"allowedTeams,omitempty"`
			Enabled         *bool     `json:"enabled,omitempty"`
		} `json:"federation,omitempty"`

		// ReleaseChannel Name of the release channel for automatic version updates
		ReleaseChannel *string `json:"releaseChannel,omitempty"`
	} `json:"spec,omitempty"`

	// Status Observed state of the Unleash instance
	Status *struct {
		// Connected Connection status to database
		Connected *bool `json:"connected,omitempty"`

		// Version Current running version
		Version *string `json:"version,omitempty"`
	} `json:"status,omitempty"`
}

// UnleashConfigRequest Request body for creating or updating an Unleash instance
type UnleashConfigRequest struct {
	// AllowedClusters Comma-separated list of allowed clusters for federation
	AllowedClusters *string `json:"allowed_clusters,omitempty"`

	// AllowedTeams Comma-separated list of allowed teams for federation
	AllowedTeams *string `json:"allowed_teams,omitempty"`

	// DatabasePoolIdleTimeoutMs Database connection idle timeout in milliseconds
	DatabasePoolIdleTimeoutMs *int `json:"database_pool_idle_timeout_ms,omitempty"`

	// DatabasePoolMax Maximum number of database connections
	DatabasePoolMax *int `json:"database_pool_max,omitempty"`

	// EnableFederation Enable federation support (always enabled for managed instances)
	EnableFederation *bool `json:"enable_federation,omitempty"`

	// LogLevel Log level for the Unleash instance
	LogLevel *UnleashConfigRequestLogLevel `json:"log_level,omitempty"`

	// Name Name of the Unleash instance
	Name *string `json:"name,omitempty"`

	// ReleaseChannelName Name of the release channel to use for automatic version updates
	ReleaseChannelName *string `json:"release_channel_name,omitempty"`
}

// UnleashConfigRequestLogLevel Log level for the Unleash instance
type UnleashConfigRequestLogLevel string

// CreateInstanceJSONRequestBody defines body for CreateInstance for application/json ContentType.
type CreateInstanceJSONRequestBody = UnleashConfigRequest

// UpdateInstanceJSONRequestBody defines body for UpdateInstance for application/json ContentType.
type UpdateInstanceJSONRequestBody = UnleashConfigRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all release channels
	// (GET /v1/releasechannels)
	ListChannels(c *gin.Context)
	// Get a release channel by name
	// (GET /v1/releasechannels/{name})
	GetChannel(c *gin.Context, name string)
	// List all Unleash instances
	// (GET /v1/unleash)
	ListInstances(c *gin.Context)
	// Create a new Unleash instance
	// (POST /v1/unleash)
	CreateInstance(c *gin.Context)
	// Delete an Unleash instance
	// (DELETE /v1/unleash/{name})
	DeleteInstance(c *gin.Context, name string)
	// Get Unleash instance by name
	// (GET /v1/unleash/{name})
	GetInstance(c *gin.Context, name string)
	// Update an existing Unleash instance
	// (PUT /v1/unleash/{name})
	UpdateInstance(c *gin.Context, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListChannels operation middleware
func (siw *ServerInterfaceWrapper) ListChannels(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListChannels(c)
}

// GetChannel operation middleware
func (siw *ServerInterfaceWrapper) GetChannel(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetChannel(c, name)
}

// ListInstances operation middleware
func (siw *ServerInterfaceWrapper) ListInstances(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListInstances(c)
}

// CreateInstance operation middleware
func (siw *ServerInterfaceWrapper) CreateInstance(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateInstance(c)
}

// DeleteInstance operation middleware
func (siw *ServerInterfaceWrapper) DeleteInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteInstance(c, name)
}

// GetInstance operation middleware
func (siw *ServerInterfaceWrapper) GetInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetInstance(c, name)
}

// UpdateInstance operation middleware
func (siw *ServerInterfaceWrapper) UpdateInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateInstance(c, name)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/v1/releasechannels", wrapper.ListChannels)
	router.GET(options.BaseURL+"/v1/releasechannels/:name", wrapper.GetChannel)
	router.GET(options.BaseURL+"/v1/unleash", wrapper.ListInstances)
	router.POST(options.BaseURL+"/v1/unleash", wrapper.CreateInstance)
	router.DELETE(options.BaseURL+"/v1/unleash/:name", wrapper.DeleteInstance)
	router.GET(options.BaseURL+"/v1/unleash/:name", wrapper.GetInstance)
	router.PUT(options.BaseURL+"/v1/unleash/:name", wrapper.UpdateInstance)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
